

/* This file was generated by JSON Schema to C.
 * Any changes made to it will be lost on regeneration. 

 * Copyright (C) Roman Arutyunyan
 * Copyright (C) Nginx, Inc.
 * Copyright (C) 2021-2023  TMLake(Beijing) Technology Co., Ltd.
 */

#include <njt_core.h>
#include "njt_http_dyn_bwlist_parser.h"
#include <js2c_njet_builtins.h>
/* ========================== Generated parsers ========================== */

static bool parse_locationDef(njt_pool_t *pool, parse_state_t *parse_state, locationDef_t *out, njt_str_t* err_str); //forward decl for public definition
static void get_json_length_locationDef(locationDef_t *out, size_t *length, njt_int_t flags); //forward decl for public definition
static void to_oneline_json_locationDef(locationDef_t *out, njt_str_t *buf, njt_int_t flags); //forward decl for public definition

static bool parse_locationDef_accessIpv4_item_rule(njt_pool_t *pool, parse_state_t *parse_state, locationDef_accessIpv4_item_rule_t *out, njt_str_t *err_str) {
    if (check_type(pool, parse_state, JSMN_STRING, err_str)) {
        return true;
    }
    if (current_string_is(parse_state, "allow")) {
        *out = LOCATIONDEF_ACCESSIPV4_ITEM_RULE_ALLOW;
    } else if (current_string_is(parse_state, "deny")) {
        *out = LOCATIONDEF_ACCESSIPV4_ITEM_RULE_DENY;
    } else {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_locationDef_accessIpv4_item(njt_pool_t *pool, parse_state_t *parse_state, locationDef_accessIpv4_item_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_rule = false;
    bool seen_addr = false;
    bool seen_mask = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "rule")) {
            if (seen_rule) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': rule", parse_state->current_key)
                return true;
            }
            seen_rule = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "rule";
            if (parse_locationDef_accessIpv4_item_rule(pool, parse_state, (&out->rule), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "addr")) {
            if (seen_addr) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': addr", parse_state->current_key)
                return true;
            }
            seen_addr = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "addr";
            out->addr = njt_palloc(pool, sizeof(njt_str_t));
            if (out->addr == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->addr) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->addr) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->addr))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->addr))->len = token_size;
            if ((out->addr)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->addr))->data, 0, ((out->addr))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "mask")) {
            if (seen_mask) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': mask", parse_state->current_key)
                return true;
            }
            seen_mask = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "mask";
            out->mask = njt_palloc(pool, sizeof(njt_str_t));
            if (out->mask == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->mask) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->mask) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->mask))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->mask))->len = token_size;
            if ((out->mask)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->mask))->data, 0, ((out->mask))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_rule) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': rule", parse_state->current_key)
        return true;
    }
    if (!seen_addr) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': addr", parse_state->current_key)
        return true;
    }
    if (!seen_mask) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': mask", parse_state->current_key)
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_locationDef_accessIpv4(njt_pool_t *pool, parse_state_t *parse_state, locationDef_accessIpv4_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((locationDef_accessIpv4_item_t**)out->elts)[i] = njt_palloc(pool, sizeof(locationDef_accessIpv4_item_t));
        if (parse_locationDef_accessIpv4_item(pool, parse_state, ((locationDef_accessIpv4_item_t**)out->elts)[i], err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_locationDef_accessIpv6_item_rule(njt_pool_t *pool, parse_state_t *parse_state, locationDef_accessIpv6_item_rule_t *out, njt_str_t *err_str) {
    if (check_type(pool, parse_state, JSMN_STRING, err_str)) {
        return true;
    }
    if (current_string_is(parse_state, "allow")) {
        *out = LOCATIONDEF_ACCESSIPV6_ITEM_RULE_ALLOW;
    } else if (current_string_is(parse_state, "deny")) {
        *out = LOCATIONDEF_ACCESSIPV6_ITEM_RULE_DENY;
    } else {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown enum value in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
        return true;
    }
    parse_state->current_token += 1;
    return false;
}


static bool parse_locationDef_accessIpv6_item(njt_pool_t *pool, parse_state_t *parse_state, locationDef_accessIpv6_item_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_rule = false;
    bool seen_addr = false;
    bool seen_mask = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "rule")) {
            if (seen_rule) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': rule", parse_state->current_key)
                return true;
            }
            seen_rule = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "rule";
            if (parse_locationDef_accessIpv6_item_rule(pool, parse_state, (&out->rule), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "addr")) {
            if (seen_addr) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': addr", parse_state->current_key)
                return true;
            }
            seen_addr = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "addr";
            out->addr = njt_palloc(pool, sizeof(njt_str_t));
            if (out->addr == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->addr) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->addr) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->addr))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->addr))->len = token_size;
            if ((out->addr)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->addr))->data, 0, ((out->addr))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "mask")) {
            if (seen_mask) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': mask", parse_state->current_key)
                return true;
            }
            seen_mask = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "mask";
            out->mask = njt_palloc(pool, sizeof(njt_str_t));
            if (out->mask == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->mask) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->mask) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->mask))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->mask))->len = token_size;
            if ((out->mask)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->mask))->data, 0, ((out->mask))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_rule) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': rule", parse_state->current_key)
        return true;
    }
    if (!seen_addr) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': addr", parse_state->current_key)
        return true;
    }
    if (!seen_mask) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': mask", parse_state->current_key)
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_locationDef_accessIpv6(njt_pool_t *pool, parse_state_t *parse_state, locationDef_accessIpv6_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((locationDef_accessIpv6_item_t**)out->elts)[i] = njt_palloc(pool, sizeof(locationDef_accessIpv6_item_t));
        if (parse_locationDef_accessIpv6_item(pool, parse_state, ((locationDef_accessIpv6_item_t**)out->elts)[i], err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_locationDef_locations(njt_pool_t *pool, parse_state_t *parse_state, locationDef_locations_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((locationDef_locations_item_t**)out->elts)[i] = njt_palloc(pool, sizeof(locationDef_t));
        if (parse_locationDef(pool, parse_state, ((locationDef_locations_item_t**)out->elts)[i], err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_locationDef(njt_pool_t *pool, parse_state_t *parse_state, locationDef_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_location = false;
    bool seen_accessIpv4 = false;
    bool seen_accessIpv6 = false;
    bool seen_locations = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "location")) {
            if (seen_location) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': location", parse_state->current_key)
                return true;
            }
            seen_location = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "location";
            out->location = njt_palloc(pool, sizeof(njt_str_t));
            if (out->location == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->location) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->location) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->location))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->location))->len = token_size;
            if ((out->location)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->location))->data, 0, ((out->location))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "accessIpv4")) {
            if (seen_accessIpv4) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': accessIpv4", parse_state->current_key)
                return true;
            }
            seen_accessIpv4 = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "accessIpv4";
            out->accessIpv4 = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(locationDef_accessIpv4_item_t*));
            if (out->accessIpv4 == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_locationDef_accessIpv4(pool, parse_state, (out->accessIpv4), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "accessIpv6")) {
            if (seen_accessIpv6) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': accessIpv6", parse_state->current_key)
                return true;
            }
            seen_accessIpv6 = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "accessIpv6";
            out->accessIpv6 = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(locationDef_accessIpv6_item_t*));
            if (out->accessIpv6 == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_locationDef_accessIpv6(pool, parse_state, (out->accessIpv6), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "locations")) {
            if (seen_locations) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': locations", parse_state->current_key)
                return true;
            }
            seen_locations = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "locations";
            out->locations = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(locationDef_locations_item_t*));
            if (out->locations == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_locationDef_locations(pool, parse_state, (out->locations), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_location) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': location", parse_state->current_key)
        return true;
    }
    // HAHB
    if (!seen_accessIpv4) {
        out->accessIpv4 = njt_palloc(pool, sizeof(njt_array_t));
        memset(out->accessIpv4, 0, sizeof(njt_array_t));
    }
    // HAHB
    if (!seen_accessIpv6) {
        out->accessIpv6 = njt_palloc(pool, sizeof(njt_array_t));
        memset(out->accessIpv6, 0, sizeof(njt_array_t));
    }
    // HAHB
    if (!seen_locations) {
        out->locations = njt_palloc(pool, sizeof(njt_array_t));
        memset(out->locations, 0, sizeof(njt_array_t));
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_locationDef_location(locationDef_location_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_locationDef_accessIpv4_item_rule(locationDef_accessIpv4_item_rule_t *out, size_t *length, njt_int_t flags) {
    if (*out == LOCATIONDEF_ACCESSIPV4_ITEM_RULE_ALLOW) {
        // "allow"
        *length += 5 + 2;
        return;
    }
    if (*out == LOCATIONDEF_ACCESSIPV4_ITEM_RULE_DENY) {
        // "deny"
        *length += 4 + 2;
        return;
    }
}

static void get_json_length_locationDef_accessIpv4_item_addr(locationDef_accessIpv4_item_addr_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_locationDef_accessIpv4_item_mask(locationDef_accessIpv4_item_mask_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_locationDef_accessIpv4_item(locationDef_accessIpv4_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if (omit == 0) {
        *length += (4 + 3); // "rule": 
        get_json_length_locationDef_accessIpv4_item_rule((&out->rule), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->addr) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "addr": 
        get_json_length_locationDef_accessIpv4_item_addr((&out->addr), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->mask) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "mask": 
        get_json_length_locationDef_accessIpv4_item_mask((&out->mask), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_locationDef_accessIpv4(locationDef_accessIpv4_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((locationDef_accessIpv4_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_locationDef_accessIpv4_item(((locationDef_accessIpv4_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}
// BEGIN GET_JSON_LENGTH ENUM

static void get_json_length_locationDef_accessIpv6_item_rule(locationDef_accessIpv6_item_rule_t *out, size_t *length, njt_int_t flags) {
    if (*out == LOCATIONDEF_ACCESSIPV6_ITEM_RULE_ALLOW) {
        // "allow"
        *length += 5 + 2;
        return;
    }
    if (*out == LOCATIONDEF_ACCESSIPV6_ITEM_RULE_DENY) {
        // "deny"
        *length += 4 + 2;
        return;
    }
}

static void get_json_length_locationDef_accessIpv6_item_addr(locationDef_accessIpv6_item_addr_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_locationDef_accessIpv6_item_mask(locationDef_accessIpv6_item_mask_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_locationDef_accessIpv6_item(locationDef_accessIpv6_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if (omit == 0) {
        *length += (4 + 3); // "rule": 
        get_json_length_locationDef_accessIpv6_item_rule((&out->rule), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->addr) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "addr": 
        get_json_length_locationDef_accessIpv6_item_addr((&out->addr), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->mask) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "mask": 
        get_json_length_locationDef_accessIpv6_item_mask((&out->mask), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_locationDef_accessIpv6(locationDef_accessIpv6_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((locationDef_accessIpv6_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_locationDef_accessIpv6_item(((locationDef_accessIpv6_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}
// GET_JSON_LENGTH_REF

static void get_json_length_locationDef_locations_item(locationDef_locations_item_t *out, size_t *length, njt_int_t flags) {
    get_json_length_locationDef(out, length, flags);
}

static void get_json_length_locationDef_locations(locationDef_locations_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((locationDef_locations_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_locationDef_locations_item(((locationDef_locations_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_locationDef(locationDef_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->location) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (8 + 3); // "location": 
        get_json_length_locationDef_location((&out->location), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->accessIpv4) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (10 + 3); // "accessIpv4": 
        get_json_length_locationDef_accessIpv4((out->accessIpv4), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->accessIpv6) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (10 + 3); // "accessIpv6": 
        get_json_length_locationDef_accessIpv6((out->accessIpv6), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->locations) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (9 + 3); // "locations": 
        get_json_length_locationDef_locations((out->locations), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

locationDef_accessIpv4_item_rule_t get_locationDef_accessIpv4_item_rule(locationDef_accessIpv4_item_t *out) {
    return out->rule;
}

locationDef_accessIpv4_item_addr_t get_locationDef_accessIpv4_item_addr(locationDef_accessIpv4_item_t *out) {
    return out->addr;
}

locationDef_accessIpv4_item_mask_t get_locationDef_accessIpv4_item_mask(locationDef_accessIpv4_item_t *out) {
    return out->mask;
}
// CHECK ARRAY not exceeding bounds before call this func

locationDef_accessIpv4_item_t get_locationDef_accessIpv4_item(locationDef_accessIpv4_t *out, size_t idx) {
    return *((locationDef_accessIpv4_item_t**)out->elts)[idx];
}

locationDef_accessIpv6_item_rule_t get_locationDef_accessIpv6_item_rule(locationDef_accessIpv6_item_t *out) {
    return out->rule;
}

locationDef_accessIpv6_item_addr_t get_locationDef_accessIpv6_item_addr(locationDef_accessIpv6_item_t *out) {
    return out->addr;
}

locationDef_accessIpv6_item_mask_t get_locationDef_accessIpv6_item_mask(locationDef_accessIpv6_item_t *out) {
    return out->mask;
}
// CHECK ARRAY not exceeding bounds before call this func

locationDef_accessIpv6_item_t get_locationDef_accessIpv6_item(locationDef_accessIpv6_t *out, size_t idx) {
    return *((locationDef_accessIpv6_item_t**)out->elts)[idx];
}
// CHECK ARRAY not exceeding bounds before call this func

locationDef_locations_item_t get_locationDef_locations_item(locationDef_locations_t *out, size_t idx) {
    return *((locationDef_locations_item_t**)out->elts)[idx];
}

locationDef_location_t get_locationDef_location(locationDef_t *out) {
    return out->location;
}

locationDef_accessIpv4_t* get_locationDef_accessIpv4(locationDef_t *out) {
    return out->accessIpv4;
}

locationDef_accessIpv6_t* get_locationDef_accessIpv6(locationDef_t *out) {
    return out->accessIpv6;
}

locationDef_locations_t* get_locationDef_locations(locationDef_t *out) {
    return out->locations;
}
void set_locationDef_location(locationDef_t* obj, locationDef_location_t field) {
    obj->location = field;
}
void set_locationDef_accessIpv4_item_addr(locationDef_accessIpv4_item_t* obj, locationDef_accessIpv4_item_addr_t field) {
    obj->addr = field;
}
void set_locationDef_accessIpv4_item_mask(locationDef_accessIpv4_item_t* obj, locationDef_accessIpv4_item_mask_t field) {
    obj->mask = field;
}
locationDef_accessIpv4_item_t* create_locationDef_accessIpv4_item(njt_pool_t *pool) {
    locationDef_accessIpv4_item_t* out = njt_palloc(pool, sizeof(locationDef_accessIpv4_item_t));
    memset(out, 0, sizeof(locationDef_accessIpv4_item_t));
    return out;
}
int add_item_locationDef_accessIpv4(locationDef_accessIpv4_t *src, locationDef_accessIpv4_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

locationDef_accessIpv4_t* create_locationDef_accessIpv4(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(locationDef_accessIpv4_item_t*));
}
void set_locationDef_accessIpv4(locationDef_t* obj, locationDef_accessIpv4_t* field) {
    obj->accessIpv4 = field;
}
void set_locationDef_accessIpv6_item_addr(locationDef_accessIpv6_item_t* obj, locationDef_accessIpv6_item_addr_t field) {
    obj->addr = field;
}
void set_locationDef_accessIpv6_item_mask(locationDef_accessIpv6_item_t* obj, locationDef_accessIpv6_item_mask_t field) {
    obj->mask = field;
}
locationDef_accessIpv6_item_t* create_locationDef_accessIpv6_item(njt_pool_t *pool) {
    locationDef_accessIpv6_item_t* out = njt_palloc(pool, sizeof(locationDef_accessIpv6_item_t));
    memset(out, 0, sizeof(locationDef_accessIpv6_item_t));
    return out;
}
int add_item_locationDef_accessIpv6(locationDef_accessIpv6_t *src, locationDef_accessIpv6_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

locationDef_accessIpv6_t* create_locationDef_accessIpv6(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(locationDef_accessIpv6_item_t*));
}
void set_locationDef_accessIpv6(locationDef_t* obj, locationDef_accessIpv6_t* field) {
    obj->accessIpv6 = field;
}
int add_item_locationDef_locations(locationDef_locations_t *src, locationDef_locations_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

locationDef_locations_t* create_locationDef_locations(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(locationDef_locations_item_t*));
}
void set_locationDef_locations(locationDef_t* obj, locationDef_locations_t* field) {
    obj->locations = field;
}
locationDef_t* create_locationDef(njt_pool_t *pool) {
    locationDef_t* out = njt_palloc(pool, sizeof(locationDef_t));
    memset(out, 0, sizeof(locationDef_t));
    return out;
}

static void to_oneline_json_locationDef_location(locationDef_location_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_locationDef_accessIpv4_item_rule(locationDef_accessIpv4_item_rule_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == LOCATIONDEF_ACCESSIPV4_ITEM_RULE_ALLOW) {
        cur = njt_sprintf(cur, "\"allow\"");
        buf->len += 5 + 2;
        return;
    }
    if (*out == LOCATIONDEF_ACCESSIPV4_ITEM_RULE_DENY) {
        cur = njt_sprintf(cur, "\"deny\"");
        buf->len += 4 + 2;
        return;
    }
}

static void to_oneline_json_locationDef_accessIpv4_item_addr(locationDef_accessIpv4_item_addr_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_locationDef_accessIpv4_item_mask(locationDef_accessIpv4_item_mask_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_locationDef_accessIpv4_item(locationDef_accessIpv4_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"rule\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv4_item_rule((&out->rule), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->addr) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"addr\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv4_item_addr((&out->addr), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->mask) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"mask\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv4_item_mask((&out->mask), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_locationDef_accessIpv4(locationDef_accessIpv4_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((locationDef_accessIpv4_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_locationDef_accessIpv4_item(((locationDef_accessIpv4_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_locationDef_accessIpv6_item_rule(locationDef_accessIpv6_item_rule_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out == LOCATIONDEF_ACCESSIPV6_ITEM_RULE_ALLOW) {
        cur = njt_sprintf(cur, "\"allow\"");
        buf->len += 5 + 2;
        return;
    }
    if (*out == LOCATIONDEF_ACCESSIPV6_ITEM_RULE_DENY) {
        cur = njt_sprintf(cur, "\"deny\"");
        buf->len += 4 + 2;
        return;
    }
}

static void to_oneline_json_locationDef_accessIpv6_item_addr(locationDef_accessIpv6_item_addr_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_locationDef_accessIpv6_item_mask(locationDef_accessIpv6_item_mask_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_locationDef_accessIpv6_item(locationDef_accessIpv6_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"rule\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv6_item_rule((&out->rule), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->addr) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"addr\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv6_item_addr((&out->addr), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->mask) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"mask\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv6_item_mask((&out->mask), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_locationDef_accessIpv6(locationDef_accessIpv6_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((locationDef_accessIpv6_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_locationDef_accessIpv6_item(((locationDef_accessIpv6_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}
// to_oneline_json_REF

static void to_oneline_json_locationDef_locations_item(locationDef_locations_item_t *out, njt_str_t* buf, njt_int_t flags) {
    to_oneline_json_locationDef(out, buf, flags);
}

static void to_oneline_json_locationDef_locations(locationDef_locations_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((locationDef_locations_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_locationDef_locations_item(((locationDef_locations_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_locationDef(locationDef_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->location) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"location\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_location((&out->location), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->accessIpv4) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"accessIpv4\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv4((out->accessIpv4), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->accessIpv6) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"accessIpv6\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_accessIpv6((out->accessIpv6), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->locations) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"locations\":");
        buf->len = cur - buf->data;
        to_oneline_json_locationDef_locations((out->locations), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static bool parse_dynbwlist_servers_item_listens(njt_pool_t *pool, parse_state_t *parse_state, dynbwlist_servers_item_listens_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((dynbwlist_servers_item_listens_item_t*)out->elts)[i] = njt_palloc(pool, sizeof(njt_str_t));
        // first get str len from TOKEN_STRING
        int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
        ((dynbwlist_servers_item_listens_item_t*)out->elts)[i] = njt_palloc(pool, sizeof(njt_str_t));
        if (((dynbwlist_servers_item_listens_item_t*)out->elts)[i] == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        (((dynbwlist_servers_item_listens_item_t*)out->elts)[i])->data = njt_palloc(pool, (size_t)(token_size));
        (((dynbwlist_servers_item_listens_item_t*)out->elts)[i])->len = token_size;
        if (((dynbwlist_servers_item_listens_item_t*)out->elts)[i]->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        if (builtin_parse_string(pool, parse_state, (char *)(((dynbwlist_servers_item_listens_item_t*)out->elts)[i])->data, 0, (((dynbwlist_servers_item_listens_item_t*)out->elts)[i])->len, err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dynbwlist_servers_item_serverNames(njt_pool_t *pool, parse_state_t *parse_state, dynbwlist_servers_item_serverNames_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i] = njt_palloc(pool, sizeof(njt_str_t));
        // first get str len from TOKEN_STRING
        int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
        ((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i] = njt_palloc(pool, sizeof(njt_str_t));
        if (((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i] == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        (((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i])->data = njt_palloc(pool, (size_t)(token_size));
        (((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i])->len = token_size;
        if (((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i]->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        if (builtin_parse_string(pool, parse_state, (char *)(((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i])->data, 0, (((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i])->len, err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dynbwlist_servers_item_locations(njt_pool_t *pool, parse_state_t *parse_state, dynbwlist_servers_item_locations_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((dynbwlist_servers_item_locations_item_t**)out->elts)[i] = njt_palloc(pool, sizeof(locationDef_t));
        if (parse_locationDef(pool, parse_state, ((dynbwlist_servers_item_locations_item_t**)out->elts)[i], err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dynbwlist_servers_item(njt_pool_t *pool, parse_state_t *parse_state, dynbwlist_servers_item_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_listens = false;
    bool seen_serverNames = false;
    bool seen_locations = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "listens")) {
            if (seen_listens) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': listens", parse_state->current_key)
                return true;
            }
            seen_listens = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "listens";
            out->listens = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dynbwlist_servers_item_listens_item_t*));
            if (out->listens == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_dynbwlist_servers_item_listens(pool, parse_state, (out->listens), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "serverNames")) {
            if (seen_serverNames) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': serverNames", parse_state->current_key)
                return true;
            }
            seen_serverNames = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "serverNames";
            out->serverNames = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dynbwlist_servers_item_serverNames_item_t*));
            if (out->serverNames == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_dynbwlist_servers_item_serverNames(pool, parse_state, (out->serverNames), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "locations")) {
            if (seen_locations) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': locations", parse_state->current_key)
                return true;
            }
            seen_locations = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "locations";
            out->locations = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dynbwlist_servers_item_locations_item_t*));
            if (out->locations == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_dynbwlist_servers_item_locations(pool, parse_state, (out->locations), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_listens) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': listens", parse_state->current_key)
        return true;
    }
    if (!seen_serverNames) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': serverNames", parse_state->current_key)
        return true;
    }
    if (!seen_locations) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': locations", parse_state->current_key)
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_dynbwlist_servers(njt_pool_t *pool, parse_state_t *parse_state, dynbwlist_servers_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((dynbwlist_servers_item_t**)out->elts)[i] = njt_palloc(pool, sizeof(dynbwlist_servers_item_t));
        if (parse_dynbwlist_servers_item(pool, parse_state, ((dynbwlist_servers_item_t**)out->elts)[i], err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_dynbwlist(njt_pool_t *pool, parse_state_t *parse_state, dynbwlist_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_servers = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "servers")) {
            if (seen_servers) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': servers", parse_state->current_key)
                return true;
            }
            seen_servers = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "servers";
            out->servers = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(dynbwlist_servers_item_t*));
            if (out->servers == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_dynbwlist_servers(pool, parse_state, (out->servers), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_servers) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': servers", parse_state->current_key)
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_dynbwlist_servers_item_listens_item(dynbwlist_servers_item_listens_item_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_dynbwlist_servers_item_listens(dynbwlist_servers_item_listens_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_STR) && (&((dynbwlist_servers_item_listens_item_t*)out->elts)[i]) == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_dynbwlist_servers_item_listens_item((&((dynbwlist_servers_item_listens_item_t*)out->elts)[i]), length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dynbwlist_servers_item_serverNames_item(dynbwlist_servers_item_serverNames_item_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_dynbwlist_servers_item_serverNames(dynbwlist_servers_item_serverNames_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_STR) && (&((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i]) == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_dynbwlist_servers_item_serverNames_item((&((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i]), length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}
// GET_JSON_LENGTH_REF

static void get_json_length_dynbwlist_servers_item_locations_item(dynbwlist_servers_item_locations_item_t *out, size_t *length, njt_int_t flags) {
    get_json_length_locationDef(out, length, flags);
}

static void get_json_length_dynbwlist_servers_item_locations(dynbwlist_servers_item_locations_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((dynbwlist_servers_item_locations_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_dynbwlist_servers_item_locations_item(((dynbwlist_servers_item_locations_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dynbwlist_servers_item(dynbwlist_servers_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->listens) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (7 + 3); // "listens": 
        get_json_length_dynbwlist_servers_item_listens((out->listens), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->serverNames) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (11 + 3); // "serverNames": 
        get_json_length_dynbwlist_servers_item_serverNames((out->serverNames), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->locations) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (9 + 3); // "locations": 
        get_json_length_dynbwlist_servers_item_locations((out->locations), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_dynbwlist_servers(dynbwlist_servers_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((dynbwlist_servers_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_dynbwlist_servers_item(((dynbwlist_servers_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_dynbwlist(dynbwlist_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->servers) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (7 + 3); // "servers": 
        get_json_length_dynbwlist_servers((out->servers), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}
// CHECK ARRAY not exceeding bounds before call this func

dynbwlist_servers_item_listens_item_t get_dynbwlist_servers_item_listens_item(dynbwlist_servers_item_listens_t *out, size_t idx) {
    return ((dynbwlist_servers_item_listens_item_t*)out->elts)[idx];
}
// CHECK ARRAY not exceeding bounds before call this func

dynbwlist_servers_item_serverNames_item_t get_dynbwlist_servers_item_serverNames_item(dynbwlist_servers_item_serverNames_t *out, size_t idx) {
    return ((dynbwlist_servers_item_serverNames_item_t*)out->elts)[idx];
}
// CHECK ARRAY not exceeding bounds before call this func

dynbwlist_servers_item_locations_item_t get_dynbwlist_servers_item_locations_item(dynbwlist_servers_item_locations_t *out, size_t idx) {
    return *((dynbwlist_servers_item_locations_item_t**)out->elts)[idx];
}

dynbwlist_servers_item_listens_t* get_dynbwlist_servers_item_listens(dynbwlist_servers_item_t *out) {
    return out->listens;
}

dynbwlist_servers_item_serverNames_t* get_dynbwlist_servers_item_serverNames(dynbwlist_servers_item_t *out) {
    return out->serverNames;
}

dynbwlist_servers_item_locations_t* get_dynbwlist_servers_item_locations(dynbwlist_servers_item_t *out) {
    return out->locations;
}
// CHECK ARRAY not exceeding bounds before call this func

dynbwlist_servers_item_t get_dynbwlist_servers_item(dynbwlist_servers_t *out, size_t idx) {
    return *((dynbwlist_servers_item_t**)out->elts)[idx];
}

dynbwlist_servers_t* get_dynbwlist_servers(dynbwlist_t *out) {
    return out->servers;
}
int add_item_dynbwlist_servers_item_listens(dynbwlist_servers_item_listens_t *src, dynbwlist_servers_item_listens_item_t item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dynbwlist_servers_item_listens_t* create_dynbwlist_servers_item_listens(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(dynbwlist_servers_item_listens_item_t));
}
void set_dynbwlist_servers_item_listens(dynbwlist_servers_item_t* obj, dynbwlist_servers_item_listens_t* field) {
    obj->listens = field;
}
int add_item_dynbwlist_servers_item_serverNames(dynbwlist_servers_item_serverNames_t *src, dynbwlist_servers_item_serverNames_item_t item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dynbwlist_servers_item_serverNames_t* create_dynbwlist_servers_item_serverNames(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(dynbwlist_servers_item_serverNames_item_t));
}
void set_dynbwlist_servers_item_serverNames(dynbwlist_servers_item_t* obj, dynbwlist_servers_item_serverNames_t* field) {
    obj->serverNames = field;
}
int add_item_dynbwlist_servers_item_locations(dynbwlist_servers_item_locations_t *src, dynbwlist_servers_item_locations_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dynbwlist_servers_item_locations_t* create_dynbwlist_servers_item_locations(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(dynbwlist_servers_item_locations_item_t*));
}
void set_dynbwlist_servers_item_locations(dynbwlist_servers_item_t* obj, dynbwlist_servers_item_locations_t* field) {
    obj->locations = field;
}
dynbwlist_servers_item_t* create_dynbwlist_servers_item(njt_pool_t *pool) {
    dynbwlist_servers_item_t* out = njt_palloc(pool, sizeof(dynbwlist_servers_item_t));
    memset(out, 0, sizeof(dynbwlist_servers_item_t));
    return out;
}
int add_item_dynbwlist_servers(dynbwlist_servers_t *src, dynbwlist_servers_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

dynbwlist_servers_t* create_dynbwlist_servers(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(dynbwlist_servers_item_t*));
}
void set_dynbwlist_servers(dynbwlist_t* obj, dynbwlist_servers_t* field) {
    obj->servers = field;
}
dynbwlist_t* create_dynbwlist(njt_pool_t *pool) {
    dynbwlist_t* out = njt_palloc(pool, sizeof(dynbwlist_t));
    memset(out, 0, sizeof(dynbwlist_t));
    return out;
}

static void to_oneline_json_dynbwlist_servers_item_listens_item(dynbwlist_servers_item_listens_item_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_dynbwlist_servers_item_listens(dynbwlist_servers_item_listens_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_STR) && (&((dynbwlist_servers_item_listens_item_t*)out->elts)[i]) == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_dynbwlist_servers_item_listens_item((&((dynbwlist_servers_item_listens_item_t*)out->elts)[i]), buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dynbwlist_servers_item_serverNames_item(dynbwlist_servers_item_serverNames_item_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_dynbwlist_servers_item_serverNames(dynbwlist_servers_item_serverNames_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_STR) && (&((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i]) == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_dynbwlist_servers_item_serverNames_item((&((dynbwlist_servers_item_serverNames_item_t*)out->elts)[i]), buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}
// to_oneline_json_REF

static void to_oneline_json_dynbwlist_servers_item_locations_item(dynbwlist_servers_item_locations_item_t *out, njt_str_t* buf, njt_int_t flags) {
    to_oneline_json_locationDef(out, buf, flags);
}

static void to_oneline_json_dynbwlist_servers_item_locations(dynbwlist_servers_item_locations_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((dynbwlist_servers_item_locations_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_dynbwlist_servers_item_locations_item(((dynbwlist_servers_item_locations_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dynbwlist_servers_item(dynbwlist_servers_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->listens) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"listens\":");
        buf->len = cur - buf->data;
        to_oneline_json_dynbwlist_servers_item_listens((out->listens), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->serverNames) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"serverNames\":");
        buf->len = cur - buf->data;
        to_oneline_json_dynbwlist_servers_item_serverNames((out->serverNames), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->locations) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"locations\":");
        buf->len = cur - buf->data;
        to_oneline_json_dynbwlist_servers_item_locations((out->locations), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_dynbwlist_servers(dynbwlist_servers_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((dynbwlist_servers_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_dynbwlist_servers_item(((dynbwlist_servers_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_dynbwlist(dynbwlist_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->servers) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"servers\":");
        buf->len = cur - buf->data;
        to_oneline_json_dynbwlist_servers((out->servers), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}
dynbwlist_t* json_parse_dynbwlist(njt_pool_t *pool, const njt_str_t *json_string, njt_str_t *err_str) {
    dynbwlist_t* out;
    parse_state_t parse_state_var;
    parse_state_t *parse_state = &parse_state_var;
    uint64_t max_token_number = 1024;
    jsmntok_t *token_buffer;
    int parse_result;
    for ( ; /* parse unsuccessful */; ) {
        token_buffer = njt_palloc(pool, sizeof(jsmntok_t)*max_token_number);
        parse_result = builtin_parse_json_string(pool, parse_state, token_buffer, max_token_number, (char *)json_string->data, json_string->len, err_str);
        if (parse_result == JSMN_ERROR_INVAL || parse_result == JSMN_ERROR_PART) {
            // njt_pfree(pool, token_buffer);
            return NULL;
        }
        if (parse_result == JSMN_ERROR_NOMEM) {
            max_token_number += max_token_number;
            printf("max_token_number: %ld\n", max_token_number);
            continue;
        }
        if (parse_result == 0) {
            LOG_ERROR_JSON_PARSE(0, "String did not contain %s JSON tokens", "any");
            return NULL;
        }
        break; // parse success
    }
    out = njt_palloc(pool, sizeof(dynbwlist_t));;
    if (parse_dynbwlist(pool, parse_state, out, err_str)) {
        return NULL;
    }
    return out;
}

njt_str_t* to_json_dynbwlist(njt_pool_t *pool, dynbwlist_t* out, njt_int_t flags) {
    njt_str_t *json_str;
    json_str = njt_palloc(pool, sizeof(njt_str_t));
    size_t str_len = 0;
    get_json_length_dynbwlist(out, &str_len, flags);
    json_str->data = njt_palloc(pool, str_len + 1);
    json_str->len = 0;
    to_oneline_json_dynbwlist(out, json_str, flags);
    return json_str;
}
