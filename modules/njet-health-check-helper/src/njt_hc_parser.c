

/* This file was generated by JSON Schema to C.
 * Any changes made to it will be lost on regeneration. 

 * Copyright (C) Roman Arutyunyan
 * Copyright (C) Nginx, Inc.
 * Copyright (C) 2021-2023  TMLake(Beijing) Technology Co., Ltd.
 */

#include "njt_hc_parser.h"
#include "njt_core.h"
#include "js2c_njet_builtins.h"
/* ========================== Generated parsers ========================== */


static bool parse_health_check_stream(njt_pool_t *pool, parse_state_t *parse_state, health_check_stream_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_send = false;
    bool seen_expect = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "send")) {
            if (seen_send) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': send", parse_state->current_key)
                return true;
            }
            seen_send = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "send";
            out->send = njt_palloc(pool, sizeof(njt_str_t));
            if (out->send == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->send) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->send) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->send))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->send))->len = token_size;
            if ((out->send)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->send))->data, 0, ((out->send))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "expect")) {
            if (seen_expect) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': expect", parse_state->current_key)
                return true;
            }
            seen_expect = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "expect";
            out->expect = njt_palloc(pool, sizeof(njt_str_t));
            if (out->expect == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->expect) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->expect) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->expect))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->expect))->len = token_size;
            if ((out->expect)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->expect))->data, 0, ((out->expect))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // HAHB
    if (!seen_send) {
        out->send = njt_palloc(pool, sizeof(njt_str_t));
        if (out->send == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        size_t token_size = strlen("");
        (out->send)->data = njt_palloc(pool, token_size);
        (out->send)->len = token_size;
        if (out->send->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        njt_memcpy(out->send->data, "", token_size);
    }
    // HAHB
    if (!seen_expect) {
        out->expect = njt_palloc(pool, sizeof(njt_str_t));
        if (out->expect == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        size_t token_size = strlen("");
        (out->expect)->data = njt_palloc(pool, token_size);
        (out->expect)->len = token_size;
        if (out->expect->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        njt_memcpy(out->expect->data, "", token_size);
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_health_check_http_header(njt_pool_t *pool, parse_state_t *parse_state, health_check_http_header_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((health_check_http_header_item_t*)out->elts)[i] = njt_palloc(pool, sizeof(njt_str_t));
        // first get str len from TOKEN_STRING
        int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
        ((health_check_http_header_item_t*)out->elts)[i] = njt_palloc(pool, sizeof(njt_str_t));
        if (((health_check_http_header_item_t*)out->elts)[i] == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        (((health_check_http_header_item_t*)out->elts)[i])->data = njt_palloc(pool, (size_t)(token_size));
        (((health_check_http_header_item_t*)out->elts)[i])->len = token_size;
        if (((health_check_http_header_item_t*)out->elts)[i]->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        if (builtin_parse_string(pool, parse_state, (char *)(((health_check_http_header_item_t*)out->elts)[i])->data, 0, (((health_check_http_header_item_t*)out->elts)[i])->len, err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_health_check_http(njt_pool_t *pool, parse_state_t *parse_state, health_check_http_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_uri = false;
    bool seen_header = false;
    bool seen_body = false;
    bool seen_status = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "uri")) {
            if (seen_uri) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': uri", parse_state->current_key)
                return true;
            }
            seen_uri = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "uri";
            out->uri = njt_palloc(pool, sizeof(njt_str_t));
            if (out->uri == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->uri) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->uri) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->uri))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->uri))->len = token_size;
            if ((out->uri)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->uri))->data, 0, ((out->uri))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "header")) {
            if (seen_header) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': header", parse_state->current_key)
                return true;
            }
            seen_header = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "header";
            out->header = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(health_check_http_header_item_t*));
            if (out->header == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_health_check_http_header(pool, parse_state, (out->header), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "body")) {
            if (seen_body) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': body", parse_state->current_key)
                return true;
            }
            seen_body = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "body";
            out->body = njt_palloc(pool, sizeof(njt_str_t));
            if (out->body == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->body) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->body) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->body))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->body))->len = token_size;
            if ((out->body)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->body))->data, 0, ((out->body))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "status")) {
            if (seen_status) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': status", parse_state->current_key)
                return true;
            }
            seen_status = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "status";
            out->status = njt_palloc(pool, sizeof(njt_str_t));
            if (out->status == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->status) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->status) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->status))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->status))->len = token_size;
            if ((out->status)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->status))->data, 0, ((out->status))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // HAHB
    if (!seen_uri) {
        out->uri = njt_palloc(pool, sizeof(njt_str_t));
        if (out->uri == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        size_t token_size = strlen("");
        (out->uri)->data = njt_palloc(pool, token_size);
        (out->uri)->len = token_size;
        if (out->uri->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        njt_memcpy(out->uri->data, "", token_size);
    }
    // HAHB
    if (!seen_header) {
        out->header = njt_palloc(pool, sizeof(njt_array_t));
        memset(out->header, 0, sizeof(njt_array_t));
    }
    // HAHB
    if (!seen_body) {
        out->body = njt_palloc(pool, sizeof(njt_str_t));
        if (out->body == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        size_t token_size = strlen("");
        (out->body)->data = njt_palloc(pool, token_size);
        (out->body)->len = token_size;
        if (out->body->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        njt_memcpy(out->body->data, "", token_size);
    }
    // HAHB
    if (!seen_status) {
        out->status = njt_palloc(pool, sizeof(njt_str_t));
        if (out->status == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        size_t token_size = strlen("");
        (out->status)->data = njt_palloc(pool, token_size);
        (out->status)->len = token_size;
        if (out->status->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        njt_memcpy(out->status->data, "", token_size);
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_health_check_ssl(njt_pool_t *pool, parse_state_t *parse_state, health_check_ssl_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_enable = false;
    bool seen_ntls = false;
    bool seen_ciphers = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "enable")) {
            if (seen_enable) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': enable", parse_state->current_key)
                return true;
            }
            seen_enable = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "enable";
            if (builtin_parse_bool(pool, parse_state, (&out->enable), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "ntls")) {
            if (seen_ntls) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': ntls", parse_state->current_key)
                return true;
            }
            seen_ntls = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "ntls";
            if (builtin_parse_bool(pool, parse_state, (&out->ntls), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "ciphers")) {
            if (seen_ciphers) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': ciphers", parse_state->current_key)
                return true;
            }
            seen_ciphers = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "ciphers";
            out->ciphers = njt_palloc(pool, sizeof(njt_str_t));
            if (out->ciphers == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->ciphers) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->ciphers) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->ciphers))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->ciphers))->len = token_size;
            if ((out->ciphers)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->ciphers))->data, 0, ((out->ciphers))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    // HAHB
    if (!seen_enable) {
        out->enable = false;
    }
    // HAHB
    if (!seen_ntls) {
        out->ntls = false;
    }
    // HAHB
    if (!seen_ciphers) {
        out->ciphers = njt_palloc(pool, sizeof(njt_str_t));
        if (out->ciphers == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        size_t token_size = strlen("DEFAULT");
        (out->ciphers)->data = njt_palloc(pool, token_size);
        (out->ciphers)->len = token_size;
        if (out->ciphers->data == NULL) {
            // TODO LOG_ERROR
            return true;
        }
        njt_memcpy(out->ciphers->data, "DEFAULT", token_size);
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_health_check(njt_pool_t *pool, parse_state_t *parse_state, health_check_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_interval = false;
    bool seen_jitter = false;
    bool seen_timeout = false;
    bool seen_passes = false;
    bool seen_fails = false;
    bool seen_port = false;
    bool seen_stream = false;
    bool seen_http = false;
    bool seen_ssl = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "interval")) {
            if (seen_interval) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': interval", parse_state->current_key)
                return true;
            }
            seen_interval = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "interval";
            out->interval = njt_palloc(pool, sizeof(njt_str_t));
            if (out->interval == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->interval) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->interval) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->interval))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->interval))->len = token_size;
            if ((out->interval)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->interval))->data, 0, ((out->interval))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "jitter")) {
            if (seen_jitter) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': jitter", parse_state->current_key)
                return true;
            }
            seen_jitter = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "jitter";
            out->jitter = njt_palloc(pool, sizeof(njt_str_t));
            if (out->jitter == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->jitter) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->jitter) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->jitter))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->jitter))->len = token_size;
            if ((out->jitter)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->jitter))->data, 0, ((out->jitter))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "timeout")) {
            if (seen_timeout) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': timeout", parse_state->current_key)
                return true;
            }
            seen_timeout = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "timeout";
            out->timeout = njt_palloc(pool, sizeof(njt_str_t));
            if (out->timeout == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->timeout) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->timeout) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->timeout))->data = njt_palloc(pool, (size_t)(token_size));
            ((out->timeout))->len = token_size;
            if ((out->timeout)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (char *)((out->timeout))->data, 0, ((out->timeout))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "passes")) {
            if (seen_passes) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': passes", parse_state->current_key)
                return true;
            }
            seen_passes = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "passes";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_str)) {
                return true;
            }
            if (!(int_parse_tmp >= 1)) {
                parse_state->current_token -= 1;
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Integer %" PRIi64 " in '%s' out of range. It must be >= 1.", int_parse_tmp, parse_state->current_key)
                return true;
            }
            *(&out->passes) = int_parse_tmp;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "fails")) {
            if (seen_fails) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': fails", parse_state->current_key)
                return true;
            }
            seen_fails = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "fails";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_str)) {
                return true;
            }
            if (!(int_parse_tmp >= 1)) {
                parse_state->current_token -= 1;
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Integer %" PRIi64 " in '%s' out of range. It must be >= 1.", int_parse_tmp, parse_state->current_key)
                return true;
            }
            *(&out->fails) = int_parse_tmp;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "port")) {
            if (seen_port) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': port", parse_state->current_key)
                return true;
            }
            seen_port = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "port";
            int64_t int_parse_tmp;
            if (builtin_parse_signed(pool, parse_state, true, false, 10, &int_parse_tmp, err_str)) {
                return true;
            }
            if (!(int_parse_tmp >= 1)) {
                parse_state->current_token -= 1;
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Integer %" PRIi64 " in '%s' out of range. It must be >= 1.", int_parse_tmp, parse_state->current_key)
                return true;
            }
            if (!(int_parse_tmp <= 65535)) {
                parse_state->current_token -= 1;
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Integer %" PRIi64 " in '%s' out of range. It must be <= 65535.", int_parse_tmp, parse_state->current_key)
                return true;
            }
            *(&out->port) = int_parse_tmp;
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "stream")) {
            if (seen_stream) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': stream", parse_state->current_key)
                return true;
            }
            seen_stream = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "stream";
            out->stream = njt_palloc(pool, sizeof(health_check_stream_t));
            if (out->stream == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_health_check_stream(pool, parse_state, (out->stream), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "http")) {
            if (seen_http) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': http", parse_state->current_key)
                return true;
            }
            seen_http = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "http";
            out->http = njt_palloc(pool, sizeof(health_check_http_t));
            if (out->http == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_health_check_http(pool, parse_state, (out->http), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "ssl")) {
            if (seen_ssl) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': ssl", parse_state->current_key)
                return true;
            }
            seen_ssl = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "ssl";
            out->ssl = njt_palloc(pool, sizeof(health_check_ssl_t));
            if (out->ssl == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_health_check_ssl(pool, parse_state, (out->ssl), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_interval) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': interval", parse_state->current_key)
        return true;
    }
    if (!seen_jitter) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': jitter", parse_state->current_key)
        return true;
    }
    if (!seen_timeout) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': timeout", parse_state->current_key)
        return true;
    }
    if (!seen_passes) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': passes", parse_state->current_key)
        return true;
    }
    if (!seen_fails) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': fails", parse_state->current_key)
        return true;
    }
    // HAHB
    if (!seen_port) {
        out->port = 0LL;
    }
    // HAHB
    if (!seen_stream) {
        out->stream = NULL;
    }
    // HAHB
    if (!seen_http) {
        out->http = NULL;
    }
    // HAHB
    if (!seen_ssl) {
        out->ssl = NULL;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_health_check_interval(health_check_interval_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_jitter(health_check_jitter_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_timeout(health_check_timeout_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_passes(health_check_passes_t *out, size_t *length, njt_int_t flags) {
    u_char str[24], *cur;
    cur = njt_sprintf(str, "%i", *out); // Convert integer to string
    *length += cur - str;
}

static void get_json_length_health_check_fails(health_check_fails_t *out, size_t *length, njt_int_t flags) {
    u_char str[24], *cur;
    cur = njt_sprintf(str, "%i", *out); // Convert integer to string
    *length += cur - str;
}

static void get_json_length_health_check_port(health_check_port_t *out, size_t *length, njt_int_t flags) {
    u_char str[24], *cur;
    cur = njt_sprintf(str, "%i", *out); // Convert integer to string
    *length += cur - str;
}

static void get_json_length_health_check_stream_send(health_check_stream_send_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_stream_expect(health_check_stream_expect_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_stream(health_check_stream_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->send) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "send": 
        get_json_length_health_check_stream_send((&out->send), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->expect) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (6 + 3); // "expect": 
        get_json_length_health_check_stream_expect((&out->expect), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_health_check_http_uri(health_check_http_uri_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_http_header_item(health_check_http_header_item_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_http_header(health_check_http_header_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_STR) && (&((health_check_http_header_item_t*)out->elts)[i]) == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_health_check_http_header_item((&((health_check_http_header_item_t*)out->elts)[i]), length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_health_check_http_body(health_check_http_body_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_http_status(health_check_http_status_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_http(health_check_http_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->uri) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (3 + 3); // "uri": 
        get_json_length_health_check_http_uri((&out->uri), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->header) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (6 + 3); // "header": 
        get_json_length_health_check_http_header((out->header), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->body) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "body": 
        get_json_length_health_check_http_body((&out->body), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->status) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (6 + 3); // "status": 
        get_json_length_health_check_http_status((&out->status), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_health_check_ssl_enable(health_check_ssl_enable_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_health_check_ssl_ntls(health_check_ssl_ntls_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_health_check_ssl_ciphers(health_check_ssl_ciphers_t *out, size_t *length, njt_int_t flags) {
    *length += (*out)->len + 2; //  "str" 
}

static void get_json_length_health_check_ssl(health_check_ssl_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if (omit == 0) {
        *length += (6 + 3); // "enable": 
        get_json_length_health_check_ssl_enable((&out->enable), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if (omit == 0) {
        *length += (4 + 3); // "ntls": 
        get_json_length_health_check_ssl_ntls((&out->ntls), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->ciphers) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (7 + 3); // "ciphers": 
        get_json_length_health_check_ssl_ciphers((&out->ciphers), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_health_check(health_check_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->interval) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (8 + 3); // "interval": 
        get_json_length_health_check_interval((&out->interval), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->jitter) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (6 + 3); // "jitter": 
        get_json_length_health_check_jitter((&out->jitter), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->timeout) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (7 + 3); // "timeout": 
        get_json_length_health_check_timeout((&out->timeout), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if (omit == 0) {
        *length += (6 + 3); // "passes": 
        get_json_length_health_check_passes((&out->passes), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if (omit == 0) {
        *length += (5 + 3); // "fails": 
        get_json_length_health_check_fails((&out->fails), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if (omit == 0) {
        *length += (4 + 3); // "port": 
        get_json_length_health_check_port((&out->port), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_OBJ) && (out->stream) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (6 + 3); // "stream": 
        get_json_length_health_check_stream((out->stream), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_OBJ) && (out->http) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "http": 
        get_json_length_health_check_http((out->http), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_OBJ) && (out->ssl) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (3 + 3); // "ssl": 
        get_json_length_health_check_ssl((out->ssl), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

health_check_stream_send_t get_health_check_stream_send(health_check_stream_t *out) {
    return out->send;
}

health_check_stream_expect_t get_health_check_stream_expect(health_check_stream_t *out) {
    return out->expect;
}
// CHECK ARRAY not exceeding bounds before call this func

health_check_http_header_item_t get_health_check_http_header_item(health_check_http_header_t *out, size_t idx) {
    return ((health_check_http_header_item_t*)out->elts)[idx];
}

health_check_http_uri_t get_health_check_http_uri(health_check_http_t *out) {
    return out->uri;
}

health_check_http_header_t* get_health_check_http_header(health_check_http_t *out) {
    return out->header;
}

health_check_http_body_t get_health_check_http_body(health_check_http_t *out) {
    return out->body;
}

health_check_http_status_t get_health_check_http_status(health_check_http_t *out) {
    return out->status;
}

health_check_ssl_enable_t get_health_check_ssl_enable(health_check_ssl_t *out) {
    return out->enable;
}

health_check_ssl_ntls_t get_health_check_ssl_ntls(health_check_ssl_t *out) {
    return out->ntls;
}

health_check_ssl_ciphers_t get_health_check_ssl_ciphers(health_check_ssl_t *out) {
    return out->ciphers;
}

health_check_interval_t get_health_check_interval(health_check_t *out) {
    return out->interval;
}

health_check_jitter_t get_health_check_jitter(health_check_t *out) {
    return out->jitter;
}

health_check_timeout_t get_health_check_timeout(health_check_t *out) {
    return out->timeout;
}

health_check_passes_t get_health_check_passes(health_check_t *out) {
    return out->passes;
}

health_check_fails_t get_health_check_fails(health_check_t *out) {
    return out->fails;
}

health_check_port_t get_health_check_port(health_check_t *out) {
    return out->port;
}

health_check_stream_t* get_health_check_stream(health_check_t *out) {
    return out->stream;
}

health_check_http_t* get_health_check_http(health_check_t *out) {
    return out->http;
}

health_check_ssl_t* get_health_check_ssl(health_check_t *out) {
    return out->ssl;
}
void set_health_check_interval(health_check_t* obj, health_check_interval_t field) {
    obj->interval = field;
}
void set_health_check_jitter(health_check_t* obj, health_check_jitter_t field) {
    obj->jitter = field;
}
void set_health_check_timeout(health_check_t* obj, health_check_timeout_t field) {
    obj->timeout = field;
}
void set_health_check_stream_send(health_check_stream_t* obj, health_check_stream_send_t field) {
    obj->send = field;
}
void set_health_check_stream_expect(health_check_stream_t* obj, health_check_stream_expect_t field) {
    obj->expect = field;
}
health_check_stream_t* create_health_check_stream(njt_pool_t *pool) {
    health_check_stream_t* out = njt_palloc(pool, sizeof(health_check_stream_t));
    memset(out, 0, sizeof(health_check_stream_t));
    return out;
}
void set_health_check_stream(health_check_t* obj, health_check_stream_t* field) {
    obj->stream = field;
}
void set_health_check_http_uri(health_check_http_t* obj, health_check_http_uri_t field) {
    obj->uri = field;
}
int add_item_health_check_http_header(health_check_http_header_t *src, health_check_http_header_item_t item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

health_check_http_header_t* create_health_check_http_header(njt_pool_t *pool, size_t length) {
    return njt_array_create(pool, length, sizeof(health_check_http_header_item_t));
}
void set_health_check_http_header(health_check_http_t* obj, health_check_http_header_t* field) {
    obj->header = field;
}
void set_health_check_http_body(health_check_http_t* obj, health_check_http_body_t field) {
    obj->body = field;
}
void set_health_check_http_status(health_check_http_t* obj, health_check_http_status_t field) {
    obj->status = field;
}
health_check_http_t* create_health_check_http(njt_pool_t *pool) {
    health_check_http_t* out = njt_palloc(pool, sizeof(health_check_http_t));
    memset(out, 0, sizeof(health_check_http_t));
    return out;
}
void set_health_check_http(health_check_t* obj, health_check_http_t* field) {
    obj->http = field;
}
void set_health_check_ssl_ciphers(health_check_ssl_t* obj, health_check_ssl_ciphers_t field) {
    obj->ciphers = field;
}
health_check_ssl_t* create_health_check_ssl(njt_pool_t *pool) {
    health_check_ssl_t* out = njt_palloc(pool, sizeof(health_check_ssl_t));
    memset(out, 0, sizeof(health_check_ssl_t));
    return out;
}
void set_health_check_ssl(health_check_t* obj, health_check_ssl_t* field) {
    obj->ssl = field;
}
health_check_t* create_health_check(njt_pool_t *pool) {
    health_check_t* out = njt_palloc(pool, sizeof(health_check_t));
    memset(out, 0, sizeof(health_check_t));
    return out;
}

static void to_oneline_json_health_check_interval(health_check_interval_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_jitter(health_check_jitter_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_timeout(health_check_timeout_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_passes(health_check_passes_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%i", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_fails(health_check_fails_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%i", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_port(health_check_port_t *out, njt_str_t* buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    cur = njt_sprintf(cur, "%i", *out);
    buf->len = cur - buf->data;
}

static void to_oneline_json_health_check_stream_send(health_check_stream_send_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_stream_expect(health_check_stream_expect_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_stream(health_check_stream_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->send) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"send\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_stream_send((&out->send), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->expect) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"expect\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_stream_expect((&out->expect), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_health_check_http_uri(health_check_http_uri_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_http_header_item(health_check_http_header_item_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_http_header(health_check_http_header_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_STR) && (&((health_check_http_header_item_t*)out->elts)[i]) == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_health_check_http_header_item((&((health_check_http_header_item_t*)out->elts)[i]), buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_health_check_http_body(health_check_http_body_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_http_status(health_check_http_status_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_http(health_check_http_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->uri) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"uri\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_uri((&out->uri), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->header) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"header\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_header((out->header), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->body) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"body\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_body((&out->body), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->status) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"status\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http_status((&out->status), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_health_check_ssl_enable(health_check_ssl_enable_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_health_check_ssl_ntls(health_check_ssl_ntls_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_health_check_ssl_ciphers(health_check_ssl_ciphers_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_sprintf(cur, "\"%V\"", *out);
    buf->len += (*out)->len + 2;
}

static void to_oneline_json_health_check_ssl(health_check_ssl_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"enable\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_enable((&out->enable), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"ntls\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_ntls((&out->ntls), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->ciphers) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"ciphers\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl_ciphers((&out->ciphers), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_health_check(health_check_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->interval) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"interval\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_interval((&out->interval), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->jitter) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"jitter\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_jitter((&out->jitter), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->timeout) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"timeout\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_timeout((&out->timeout), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"passes\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_passes((&out->passes), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"fails\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_fails((&out->fails), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"port\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_port((&out->port), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_OBJ) && (out->stream) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"stream\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_stream((out->stream), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_OBJ) && (out->http) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"http\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_http((out->http), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_OBJ) && (out->ssl) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"ssl\":");
        buf->len = cur - buf->data;
        to_oneline_json_health_check_ssl((out->ssl), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}
health_check_t* json_parse_health_check(njt_pool_t *pool, const njt_str_t *json_string, njt_str_t *err_str) {
    health_check_t* out;
    parse_state_t parse_state_var;
    parse_state_t *parse_state = &parse_state_var;
    uint64_t max_token_number = 1024;
    jsmntok_t *token_buffer;
    int parse_result;
    for ( ; /* parse unsuccessful */; ) {
        token_buffer = njt_palloc(pool, sizeof(jsmntok_t)*max_token_number);
        parse_result = builtin_parse_json_string(pool, parse_state, token_buffer, max_token_number, (char *)json_string->data, json_string->len, err_str);
        if (parse_result == JSMN_ERROR_INVAL || parse_result == JSMN_ERROR_PART) {
            // njt_pfree(pool, token_buffer);
            return NULL;
        }
        if (parse_result == JSMN_ERROR_NOMEM) {
            max_token_number += max_token_number;
            printf("max_token_number: %ld\n", max_token_number);
            continue;
        }
        if (parse_result == 0) {
            LOG_ERROR_JSON_PARSE(0, "String did not contain %s JSON tokens", "any");
            return NULL;
        }
        break; // parse success
    }
    out = njt_palloc(pool, sizeof(health_check_t));;
    if (parse_health_check(pool, parse_state, out, err_str)) {
        return NULL;
    }
    return out;
}

njt_str_t* to_json_health_check(njt_pool_t *pool, health_check_t* out, njt_int_t flags) {
    njt_str_t *json_str;
    json_str = njt_palloc(pool, sizeof(njt_str_t));
    size_t str_len = 0;
    get_json_length_health_check(out, &str_len, flags);
    json_str->data = njt_palloc(pool, str_len + 1);
    json_str->len = 0;
    to_oneline_json_health_check(out, json_str, flags);
    return json_str;
}
