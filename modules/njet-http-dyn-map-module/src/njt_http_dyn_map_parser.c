

/* This file was generated by JSON Schema to C.
 * Any changes made to it will be lost on regeneration. 

 * Copyright (C) 2021-2023  TMLake(Beijing) Technology Co., Ltd.
 */

#include "njt_http_dyn_map_parser.h"
#include "njt_core.h"
#include "js2c_njet_builtins.h"
/* ========================== Generated parsers ========================== */


static bool parse_httpmap_maps_item_values_item(njt_pool_t *pool, parse_state_t *parse_state, httpmap_maps_item_values_item_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_valueFrom = false;
    bool seen_valueTo = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "valueFrom")) {
            if (seen_valueFrom) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': valueFrom", parse_state->current_key)
                return true;
            }
            seen_valueFrom = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "valueFrom";
            out->valueFrom = njt_palloc(pool, sizeof(njt_str_t));
            if (out->valueFrom == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->valueFrom) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->valueFrom) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->valueFrom))->data = (u_char*)njt_palloc(pool, (size_t)(token_size));
            ((out->valueFrom))->len = token_size;
            if ((out->valueFrom)->len == 0) {
                ((out->valueFrom))->data = NULL;
            } else if ((out->valueFrom)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (out->valueFrom), 0, ((out->valueFrom))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "valueTo")) {
            if (seen_valueTo) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': valueTo", parse_state->current_key)
                return true;
            }
            seen_valueTo = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "valueTo";
            out->valueTo = njt_palloc(pool, sizeof(njt_str_t));
            if (out->valueTo == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->valueTo) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->valueTo) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->valueTo))->data = (u_char*)njt_palloc(pool, (size_t)(token_size));
            ((out->valueTo))->len = token_size;
            if ((out->valueTo)->len == 0) {
                ((out->valueTo))->data = NULL;
            } else if ((out->valueTo)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (out->valueTo), 0, ((out->valueTo))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_valueFrom) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': valueFrom", parse_state->current_key)
        return true;
    }
    if (!seen_valueTo) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': valueTo", parse_state->current_key)
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_httpmap_maps_item_values(njt_pool_t *pool, parse_state_t *parse_state, httpmap_maps_item_values_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((httpmap_maps_item_values_item_t**)out->elts)[i] = njt_palloc(pool, sizeof(httpmap_maps_item_values_item_t));
        if (parse_httpmap_maps_item_values_item(pool, parse_state, ((httpmap_maps_item_values_item_t**)out->elts)[i], err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_httpmap_maps_item(njt_pool_t *pool, parse_state_t *parse_state, httpmap_maps_item_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_keyFrom = false;
    bool seen_keyTo = false;
    bool seen_values = false;
    bool seen_isVolatile = false;
    bool seen_hostnames = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "keyFrom")) {
            if (seen_keyFrom) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': keyFrom", parse_state->current_key)
                return true;
            }
            seen_keyFrom = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "keyFrom";
            out->keyFrom = njt_palloc(pool, sizeof(njt_str_t));
            if (out->keyFrom == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->keyFrom) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->keyFrom) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->keyFrom))->data = (u_char*)njt_palloc(pool, (size_t)(token_size));
            ((out->keyFrom))->len = token_size;
            if ((out->keyFrom)->len == 0) {
                ((out->keyFrom))->data = NULL;
            } else if ((out->keyFrom)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (out->keyFrom), 2, ((out->keyFrom))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "keyTo")) {
            if (seen_keyTo) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': keyTo", parse_state->current_key)
                return true;
            }
            seen_keyTo = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "keyTo";
            out->keyTo = njt_palloc(pool, sizeof(njt_str_t));
            if (out->keyTo == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            // first get str len from TOKEN_STRING
            int token_size =  CURRENT_STRING_LENGTH(parse_state) ;
            (out->keyTo) = njt_palloc(pool, sizeof(njt_str_t));
            if ((out->keyTo) == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            ((out->keyTo))->data = (u_char*)njt_palloc(pool, (size_t)(token_size));
            ((out->keyTo))->len = token_size;
            if ((out->keyTo)->len == 0) {
                ((out->keyTo))->data = NULL;
            } else if ((out->keyTo)->data == NULL) {
                // TODO LOG_ERROR
                return true;
            }
            if (builtin_parse_string(pool, parse_state, (out->keyTo), 2, ((out->keyTo))->len, err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "values")) {
            if (seen_values) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': values", parse_state->current_key)
                return true;
            }
            seen_values = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "values";
            out->values = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(httpmap_maps_item_values_item_t*));
            if (out->values == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_httpmap_maps_item_values(pool, parse_state, (out->values), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "isVolatile")) {
            if (seen_isVolatile) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': isVolatile", parse_state->current_key)
                return true;
            }
            seen_isVolatile = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "isVolatile";
            if (builtin_parse_bool(pool, parse_state, (&out->isVolatile), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else if (current_string_is(parse_state, "hostnames")) {
            if (seen_hostnames) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': hostnames", parse_state->current_key)
                return true;
            }
            seen_hostnames = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "hostnames";
            if (builtin_parse_bool(pool, parse_state, (&out->hostnames), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_keyFrom) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': keyFrom", parse_state->current_key)
        return true;
    }
    if (!seen_keyTo) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': keyTo", parse_state->current_key)
        return true;
    }
    if (!seen_values) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': values", parse_state->current_key)
        return true;
    }
    // HAHB
    if (!seen_isVolatile) {
        out->isVolatile = false;
    }
    // HAHB
    if (!seen_hostnames) {
        out->hostnames = false;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static bool parse_httpmap_maps(njt_pool_t *pool, parse_state_t *parse_state, httpmap_maps_t *out, njt_str_t *err_str) {
    int i;
    if (check_type(pool, parse_state, JSMN_ARRAY, err_str)) {
        return true;
    }
    const int n = parse_state->tokens[parse_state->current_token].size;
    // memory has been allocate in njt_array_create.
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        // TODO CHECK write later
        ((httpmap_maps_item_t**)out->elts)[i] = njt_palloc(pool, sizeof(httpmap_maps_item_t));
        if (parse_httpmap_maps_item(pool, parse_state, ((httpmap_maps_item_t**)out->elts)[i], err_str)) {
            return true;
        }
        out->nelts ++;
    }
    return false;
}


static bool parse_httpmap(njt_pool_t *pool, parse_state_t *parse_state, httpmap_t *out, njt_str_t *err_str) {
    njt_uint_t i;
    // malloc pool for object first

    if (check_type(pool, parse_state, JSMN_OBJECT, err_str)) {
        return true;
    }
    bool seen_maps = false;
    const int object_start_token = parse_state->current_token;
    const uint64_t n = parse_state->tokens[parse_state->current_token].size;
    parse_state->current_token += 1;
    for (i = 0; i < n; ++i) {
        if (CURRENT_TOKEN(parse_state).size > 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing separator between values in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (CURRENT_TOKEN(parse_state).size < 1) {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing value in '%s', after key: %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
        if (current_string_is(parse_state, "maps")) {
            if (seen_maps) {
                LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Duplicate field definition in '%s': maps", parse_state->current_key)
                return true;
            }
            seen_maps = true;
            parse_state->current_token += 1;
            const char* saved_key = parse_state->current_key;
            parse_state->current_key = "maps";
            out->maps = njt_array_create(pool, parse_state->tokens[parse_state->current_token].size ,sizeof(httpmap_maps_item_t*));
            if (out->maps == NULL) {
                LOG_ERROR_JSON_PARSE(0, "Failed to allocate memory from %s.", "pool")
            }
            if (parse_httpmap_maps(pool, parse_state, (out->maps), err_str)) {
                return true;
            }
            parse_state->current_key = saved_key;
        } else {
            LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Unknown field in '%s': %.*s", parse_state->current_key, CURRENT_STRING_FOR_ERROR(parse_state))
            return true;
        }
    }
    const int saved_current_token = parse_state->current_token;
    parse_state->current_token = object_start_token;
    if (!seen_maps) {
        LOG_ERROR_JSON_PARSE(CURRENT_TOKEN(parse_state).start, "Missing required field in '%s': maps", parse_state->current_key)
        return true;
    }
    parse_state->current_token = saved_current_token;
    return false;
}


static void get_json_length_httpmap_maps_item_keyFrom(njt_pool_t *pool, httpmap_maps_item_keyFrom_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_httpmap_maps_item_keyTo(njt_pool_t *pool, httpmap_maps_item_keyTo_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_httpmap_maps_item_values_item_valueFrom(njt_pool_t *pool, httpmap_maps_item_values_item_valueFrom_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_httpmap_maps_item_values_item_valueTo(njt_pool_t *pool, httpmap_maps_item_values_item_valueTo_t *out, size_t *length, njt_int_t flags) {
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    *length += dst->len + 2; //  "str" 
}

static void get_json_length_httpmap_maps_item_values_item(njt_pool_t *pool, httpmap_maps_item_values_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->valueFrom) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (9 + 3); // "valueFrom": 
        get_json_length_httpmap_maps_item_values_item_valueFrom(pool, (&out->valueFrom), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->valueTo) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (7 + 3); // "valueTo": 
        get_json_length_httpmap_maps_item_values_item_valueTo(pool, (&out->valueTo), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_httpmap_maps_item_values(njt_pool_t *pool, httpmap_maps_item_values_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((httpmap_maps_item_values_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_httpmap_maps_item_values_item(pool, ((httpmap_maps_item_values_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_httpmap_maps_item_isVolatile(njt_pool_t *pool, httpmap_maps_item_isVolatile_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_httpmap_maps_item_hostnames(njt_pool_t *pool, httpmap_maps_item_hostnames_t *out, size_t *length, njt_int_t flags) {
    if (*out) {
        *length += 4; // "true"
    } else {
        *length += 5; // "false"
    }
}

static void get_json_length_httpmap_maps_item(njt_pool_t *pool, httpmap_maps_item_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->keyFrom) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (7 + 3); // "keyFrom": 
        get_json_length_httpmap_maps_item_keyFrom(pool, (&out->keyFrom), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->keyTo) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (5 + 3); // "keyTo": 
        get_json_length_httpmap_maps_item_keyTo(pool, (&out->keyTo), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->values) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (6 + 3); // "values": 
        get_json_length_httpmap_maps_item_values(pool, (out->values), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if (omit == 0) {
        *length += (10 + 3); // "isVolatile": 
        get_json_length_httpmap_maps_item_isVolatile(pool, (&out->isVolatile), length, flags);
        *length += 1; // ","
        count++;
    }
    omit = 0;
    if (omit == 0) {
        *length += (9 + 3); // "hostnames": 
        get_json_length_httpmap_maps_item_hostnames(pool, (&out->hostnames), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

static void get_json_length_httpmap_maps(njt_pool_t *pool, httpmap_maps_t *out, size_t *length, njt_int_t flags) {
    njt_uint_t i;
    njt_uint_t omit;
    njt_int_t count = 0;
    if (out == NULL) {
        *length += 2; // "[]"
        return;
    }
    *length += 2; // "[]"
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((httpmap_maps_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            get_json_length_httpmap_maps_item(pool, ((httpmap_maps_item_t**)out->elts)[i], length, flags);
            *length += 1; // ","
            count++; // ","
        }
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
}

static void get_json_length_httpmap(njt_pool_t *pool, httpmap_t *out, size_t *length, njt_int_t flags) {
    if (out == NULL) {
        *length += 4; // null
        return;
    }
    *length += 1;
    njt_int_t omit;
    njt_int_t count = 0;
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->maps) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        *length += (4 + 3); // "maps": 
        get_json_length_httpmap_maps(pool, (out->maps), length, flags);
        *length += 1; // ","
        count++;
    }
    if (count != 0) {
        *length -= 1; // "\b"
    }
    *length += 1;
}

httpmap_maps_item_values_item_valueFrom_t get_httpmap_maps_item_values_item_valueFrom(httpmap_maps_item_values_item_t *out) {
    return out->valueFrom;
}

httpmap_maps_item_values_item_valueTo_t get_httpmap_maps_item_values_item_valueTo(httpmap_maps_item_values_item_t *out) {
    return out->valueTo;
}
// CHECK ARRAY not exceeding bounds before call this func

httpmap_maps_item_values_item_t get_httpmap_maps_item_values_item(httpmap_maps_item_values_t *out, size_t idx) {
    return *((httpmap_maps_item_values_item_t**)out->elts)[idx];
}

httpmap_maps_item_keyFrom_t get_httpmap_maps_item_keyFrom(httpmap_maps_item_t *out) {
    return out->keyFrom;
}

httpmap_maps_item_keyTo_t get_httpmap_maps_item_keyTo(httpmap_maps_item_t *out) {
    return out->keyTo;
}

httpmap_maps_item_values_t* get_httpmap_maps_item_values(httpmap_maps_item_t *out) {
    return out->values;
}

httpmap_maps_item_isVolatile_t get_httpmap_maps_item_isVolatile(httpmap_maps_item_t *out) {
    return out->isVolatile;
}

httpmap_maps_item_hostnames_t get_httpmap_maps_item_hostnames(httpmap_maps_item_t *out) {
    return out->hostnames;
}
// CHECK ARRAY not exceeding bounds before call this func

httpmap_maps_item_t get_httpmap_maps_item(httpmap_maps_t *out, size_t idx) {
    return *((httpmap_maps_item_t**)out->elts)[idx];
}

httpmap_maps_t* get_httpmap_maps(httpmap_t *out) {
    return out->maps;
}
void set_httpmap_maps_item_keyFrom(httpmap_maps_item_t* obj, httpmap_maps_item_keyFrom_t field) {
    obj->keyFrom = field;
}
void set_httpmap_maps_item_keyTo(httpmap_maps_item_t* obj, httpmap_maps_item_keyTo_t field) {
    obj->keyTo = field;
}
void set_httpmap_maps_item_values_item_valueFrom(httpmap_maps_item_values_item_t* obj, httpmap_maps_item_values_item_valueFrom_t field) {
    obj->valueFrom = field;
}
void set_httpmap_maps_item_values_item_valueTo(httpmap_maps_item_values_item_t* obj, httpmap_maps_item_values_item_valueTo_t field) {
    obj->valueTo = field;
}
httpmap_maps_item_values_item_t* create_httpmap_maps_item_values_item(njt_pool_t *pool) {
    httpmap_maps_item_values_item_t* out = njt_palloc(pool, sizeof(httpmap_maps_item_values_item_t));
    memset(out, 0, sizeof(httpmap_maps_item_values_item_t));
    return out;
}
int add_item_httpmap_maps_item_values(httpmap_maps_item_values_t *src, httpmap_maps_item_values_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

httpmap_maps_item_values_t* create_httpmap_maps_item_values(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(httpmap_maps_item_values_item_t*));
}
void set_httpmap_maps_item_values(httpmap_maps_item_t* obj, httpmap_maps_item_values_t* field) {
    obj->values = field;
}
httpmap_maps_item_t* create_httpmap_maps_item(njt_pool_t *pool) {
    httpmap_maps_item_t* out = njt_palloc(pool, sizeof(httpmap_maps_item_t));
    memset(out, 0, sizeof(httpmap_maps_item_t));
    return out;
}
int add_item_httpmap_maps(httpmap_maps_t *src, httpmap_maps_item_t* item) {
    void *new = njt_array_push(src);
    if (new == NULL) {
        return NJT_ERROR;
    }
    njt_memcpy(new, &item, src->size);
    return NJT_OK;
}

httpmap_maps_t* create_httpmap_maps(njt_pool_t *pool, size_t nelts) {
    return njt_array_create(pool, nelts, sizeof(httpmap_maps_item_t*));
}
void set_httpmap_maps(httpmap_t* obj, httpmap_maps_t* field) {
    obj->maps = field;
}
httpmap_t* create_httpmap(njt_pool_t *pool) {
    httpmap_t* out = njt_palloc(pool, sizeof(httpmap_t));
    memset(out, 0, sizeof(httpmap_t));
    return out;
}

static void to_oneline_json_httpmap_maps_item_keyFrom(njt_pool_t *pool, httpmap_maps_item_keyFrom_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_httpmap_maps_item_keyTo(njt_pool_t *pool, httpmap_maps_item_keyTo_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_httpmap_maps_item_values_item_valueFrom(njt_pool_t *pool, httpmap_maps_item_values_item_valueFrom_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_httpmap_maps_item_values_item_valueTo(njt_pool_t *pool, httpmap_maps_item_values_item_valueTo_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    njt_str_t *dst = handle_escape_on_write(pool, *out);
    cur = njt_sprintf(cur, "\"%V\"", dst);
    buf->len = cur - buf->data;
}

static void to_oneline_json_httpmap_maps_item_values_item(njt_pool_t *pool, httpmap_maps_item_values_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->valueFrom) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"valueFrom\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps_item_values_item_valueFrom(pool, (&out->valueFrom), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->valueTo) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"valueTo\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps_item_values_item_valueTo(pool, (&out->valueTo), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_httpmap_maps_item_values(njt_pool_t *pool, httpmap_maps_item_values_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((httpmap_maps_item_values_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_httpmap_maps_item_values_item(pool, ((httpmap_maps_item_values_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_httpmap_maps_item_isVolatile(njt_pool_t *pool, httpmap_maps_item_isVolatile_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_httpmap_maps_item_hostnames(njt_pool_t *pool, httpmap_maps_item_hostnames_t *out, njt_str_t *buf, njt_int_t flags) {
    u_char* cur = buf->data + buf->len;
    if (*out) {
        njt_sprintf(cur, "true");
        buf->len += 4;
    } else {
        njt_sprintf(cur, "false");
        buf->len += 5;
    }
}

static void to_oneline_json_httpmap_maps_item(njt_pool_t *pool, httpmap_maps_item_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->keyFrom) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"keyFrom\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps_item_keyFrom(pool, (&out->keyFrom), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_STR) && (out->keyTo) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"keyTo\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps_item_keyTo(pool, (&out->keyTo), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->values) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"values\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps_item_values(pool, (out->values), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"isVolatile\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps_item_isVolatile(pool, (&out->isVolatile), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    omit = 0;
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"hostnames\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps_item_hostnames(pool, (&out->hostnames), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}

static void to_oneline_json_httpmap_maps(njt_pool_t *pool, httpmap_maps_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char *cur = buf->data + buf->len;
    njt_uint_t i;
    if (out == NULL || out->nelts == 0) {
        cur = njt_sprintf(cur, "[]");
        buf->len += 2;
        return;
    }
    cur = njt_sprintf(cur,  "[");
    buf->len ++;
    for (i = 0; i < out->nelts; ++i) {
        omit = 0;
        if ((flags & OMIT_NULL_OBJ) && ((httpmap_maps_item_t**)out->elts)[i] == NULL) {
            omit = 1;
        }
        if (omit == 0) {
            to_oneline_json_httpmap_maps_item(pool, ((httpmap_maps_item_t**)out->elts)[i], buf, flags);
            cur = buf->data + buf->len;
            cur = njt_sprintf(cur, ",");
            buf->len ++;
        }
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur,  "]");
    buf->len ++;
}

static void to_oneline_json_httpmap(njt_pool_t *pool, httpmap_t *out, njt_str_t* buf, njt_int_t flags) {
    njt_int_t omit;
    u_char* cur = buf->data + buf->len;
    if (out == NULL) {
        cur = njt_sprintf(cur, "null");
        buf->len += 4;
        return;
    }
    cur = njt_sprintf(cur, "{");
    buf->len ++;
    omit = 0;
    if ((flags & OMIT_NULL_ARRAY) && (out->maps) == NULL) {
        omit = 1;
    }
    if (omit == 0) {
        cur = njt_sprintf(cur, "\"maps\":");
        buf->len = cur - buf->data;
        to_oneline_json_httpmap_maps(pool, (out->maps), buf, flags);
        cur = buf->data + buf->len;
        cur = njt_sprintf(cur, ",");
        buf->len ++;
    }
    cur--;
    if (cur[0] == ',') {
        buf->len --;
    } else {
        cur ++;
    }
    cur = njt_sprintf(cur, "}");
    buf->len ++;
}
httpmap_t* json_parse_httpmap(njt_pool_t *pool, const njt_str_t *json_string, njt_str_t *err_str) {
    httpmap_t* out;
    parse_state_t parse_state_var;
    parse_state_t *parse_state = &parse_state_var;
    uint64_t max_token_number = 1024;
    jsmntok_t *token_buffer;
    int parse_result;
    for ( ; /* parse unsuccessful */; ) {
        token_buffer = njt_palloc(pool, sizeof(jsmntok_t)*max_token_number);
        parse_result = builtin_parse_json_string(pool, parse_state, token_buffer, max_token_number, (char *)json_string->data, json_string->len, err_str);
        if (parse_result == JSMN_ERROR_INVAL) {
            LOG_ERROR_JSON_PARSE(-1, "%s", "Invalid character inside JSON string");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_PART) {
            LOG_ERROR_JSON_PARSE(-1, "%s", "The string is not a full JSON packet, more bytes expected");
            return NULL;
        }
        if (parse_result == JSMN_ERROR_NOMEM) {
            max_token_number += max_token_number;
            continue;
        }
        if (parse_result == 0) {
            LOG_ERROR_JSON_PARSE(0, "String did not contain %s JSON tokens", "any");
            return NULL;
        }
        break; // parse success
    }
    out = njt_palloc(pool, sizeof(httpmap_t));;
    if (parse_httpmap(pool, parse_state, out, err_str)) {
        return NULL;
    }
    return out;
}

njt_str_t* to_json_httpmap(njt_pool_t *pool, httpmap_t* out, njt_int_t flags) {
    njt_str_t *json_str;
    json_str = njt_palloc(pool, sizeof(njt_str_t));
    size_t str_len = 0;
    get_json_length_httpmap(pool, out, &str_len, flags);
    json_str->data = (u_char*)njt_palloc(pool, str_len + 1);
    json_str->len = 0;
    to_oneline_json_httpmap(pool, out, json_str, flags);
    return json_str;
}
